//
// CWorld.CPP
//

#include "graysvr.h"	// predef header.

//////////////////////////////////////////////////////////////////
// -CQuadrant

CQuadrant :: CQuadrant()
{
	m_weather=0;
}

void CQuadrant :: OnTick()
{
	// regen all creatures and do AI
	CChar * pCharNext;
	for ( CChar * pChar = static_cast <CChar*>( m_Chars.GetHead()); pChar != NULL; pChar = pCharNext )
	{
		pCharNext = pChar->GetNext(); // static_cast <CChar*>( pChar->GetNext());
		// Can only die on your own tick.
		pChar->OnTick();
	}

	// decay items on ground = time out spells / gates etc.. etc..
	CItem * pItemNext;
	for ( CItem * pItem = static_cast <CItem*>( m_Items.GetHead()); pItem != NULL; pItem = pItemNext )
	{
		pItemNext = pItem->GetNext();
		if ( pItem->m_timeout && ( pItem->m_timeout <= World.m_Clock_Time ))
		{
			pItem->OnTick();
		}
	}

	// check for local weather change ?
}

void CQuadrant :: SetWeather( int w )
{
	// 0=dry, 1=rain or 2=snow.
	m_weather = w;
	for ( CClient * pClient = Serv.GetClientHead(); pClient!=NULL; pClient = pClient->GetNext())
	{
		if ( pClient->m_pChar == NULL ) 
			continue;
		if ( pClient->m_pChar->m_p.GetQuadrant() != this ) 
			continue;
		pClient->addWeather();
	}
}

void CQuadrant :: Close( void )
{
	m_Chars.DeleteAll();
	m_Items.DeleteAll();
	m_Regions.DeleteAll();
}

//////////////////////////////////////////////////////////////////
// -CWorldSearch

CWorldSearch :: CWorldSearch( CPoint p, int iDist )
{
	// define a search of the world.
	m_p = p;
	m_iDist = iDist;
	m_pObj = NULL;
	m_pQuad = p.GetQuadrant();
}

bool CWorldSearch :: GetNextQuadrant()
{
	// ???
	return( false );
	// m_pObj = NULL;	// start at head of next quadrant.
}

CItem * CWorldSearch :: GetItem()
{
	while ( 1 )
	{
		if ( m_pObj == NULL ) 
			m_pObj = m_pQuad->m_Items.GetHead();
		else
			m_pObj = m_pObj->GetNext();
		if ( m_pObj == NULL )
		{
			if ( GetNextQuadrant()) continue;
			return( NULL );
		}
		if ( m_p.GetDist( (static_cast <CObjBase *> (m_pObj))->m_p ) <= m_iDist )
			return( static_cast <CItem *> ( m_pObj ));
	}
}

CChar * CWorldSearch :: GetChar()
{
	while ( 1 )
	{
		if ( m_pObj == NULL ) 
			m_pObj = m_pQuad->m_Chars.GetHead();
		else
			m_pObj = m_pObj->GetNext();
		if ( m_pObj == NULL )
		{
			if ( GetNextQuadrant()) continue;
			return( NULL );
		}
		if ( m_p.GetDist( (static_cast <CObjBase*> (m_pObj))->m_p ) <= m_iDist )
			return( static_cast <CChar *> ( m_pObj ));
	}
}


//////////////////////////////////////////////////////////////////
// -CWorld

CWorld :: CWorld()
{
	m_globallight=0;
}

void CWorld :: Save() // Save world state
{
	Broadcast( "World save has been initiated." );

	CScript s;
	if ( ! s.Open( GRAY_FILE "world" GRAY_SCRIPT, true ))
	{
		DEBUG_ERR(( "ERROR:Save failed\n" ));
		return;
	}

	s.Printf( 
		"// " GRAY_TITLE " World Script\n"
		"// Generated by " GRAY_TITLE " Version " GRAY_VERSION "\n\n" );

	s.Printf( "TIME=%ld\n\n", m_Clock_Time );

	// NPC Chars and the stuff they are carrying.
	for ( int i=0; i<QUAD_QTY; i++ )
	{
		CChar * pChar = static_cast <CChar*>( m_Quads[i].m_Chars.GetHead());
		for ( ; pChar != NULL; pChar = pChar->GetNext())
		{
			pChar->Write( s );
		}
		// Items on the ground.
		CItem * pItem = (CItem*) m_Quads[i].m_Items.GetHead();
		for ( ; pItem != NULL; pItem = pItem->GetNext() )
		{
			pItem->Write( s );
		}
	}

	// Inactive Client Chars and dead npcs
	CChar * pChar = (CChar*) World.m_CharsIdle.GetHead();
	for ( ; pChar != NULL; pChar = pChar->GetNext() )
	{
		// Now move the char out to the account file.
		pChar->Write( s );
	}

	if ( Serv.m_fVerbose )
	{
		DEBUG_MSG(( "World data saved.\n" ));
	}
}

bool CWorld :: Load() // Load world from script
{
	// The world has just started.
	m_Clock_Start = m_Clock_Time = 0;

	char szFileName[ _MAX_PATH ];
	int len = sprintf( szFileName, m_sBase );

	strcpy( szFileName+len, "map0.mul" );
	if ( ! m_MapFile.Open( szFileName, false, true ))
	{
		Log.Error( "ERROR: Map %s not found...\n", szFileName );
		return( false );
	}
	strcpy( szFileName+len, "staidx0.mul" );
	if ( ! m_SIdxFile.Open( szFileName, false, true ))
	{
		Log.Error("ERROR: Statics Index %s not found...\n",szFileName);
		return( false );
	}
	strcpy( szFileName+len, "statics0.mul" );
	if ( ! m_StatFile.Open( szFileName, false, true ))
	{
		Log.Error("ERROR: Statics File %s not found...\n",szFileName);
		return( false );
	}
	strcpy( szFileName+len, "tiledata.mul" );
	if ( ! m_TileFile.Open( szFileName, false, true ))
	{
		Log.Error("ERROR: Tiles File %s not found...\n",szFileName);
		return( false );
	}

	if ( ! m_scrChars.Open( GRAY_FILE "char" GRAY_SCRIPT ))
	{
		Log.Error("ERROR: Char Script %s File not found...\n", GRAY_FILE "char" GRAY_SCRIPT );
		return( false );
	}
	if ( ! m_scrItems.Open( GRAY_FILE "item" GRAY_SCRIPT ))
	{
		Log.Error("ERROR: Char Script %s File not found...\n", GRAY_FILE "item" GRAY_SCRIPT );
		return( false );
	}
	if ( ! m_scrSpeech.Open( GRAY_FILE "spee" GRAY_SCRIPT ))
	{
		Log.Error("ERROR: Char Script %s File not found...\n", GRAY_FILE "spee" GRAY_SCRIPT );
		return( false );
	}

	CScript s;
	if ( ! s.Open( GRAY_FILE "world" GRAY_SCRIPT ))
	{
		Log.Error( "WARNING: No world data file\n" );
		return( true );
	}

	while (1)
	{
		if ( s.ReadLine() == EOF ) break;

		if ( ! memcmp( s.m_Line, "TIME", 4 ))
		{
			m_Clock_Start = m_Clock_Time = atoi( s.m_Line+5 );
		}
		else if (! memcmp( s.m_Line, "[WORLDCHAR", 10 ))
		{
			CharCreate( (CREID_TYPE) ahextoi( &s.m_Line[11] ))->Load(s);
			s.UnReadLine();	// Try the last one again.
		}
		else if (! memcmp( s.m_Line, "[WORLDITEM", 10 ))
		{
			ItemCreateScript( (ITEMID_TYPE) ahextoi( &s.m_Line[11] ))->Load(s);
			s.UnReadLine();	// Try the last one again.
		}
	}

	m_Clock_Save = m_Clock_Time + (15*60);	// next save time.
	m_Clock_StartSys = clock();

	GarbageCollection();

	return( true );
}

void CWorld :: Close()
{
	for ( int i = 0; i<QUAD_QTY; i++ )
	{
		m_Quads[i].Close();
	}
	m_CharsIdle.DeleteAll();
}

void CWorld :: GarbageCollection()
{
	// Go through the UIDs looking for Objects without links to reality.

	Log.Flush();

	// Make sure all the idle chars have valid accounts 
	CScript s;
	if ( ! s.Open( GRAY_FILE "acct" GRAY_SCRIPT )) // Open script file
		return;
	CChar * pCharNext;
	for ( CChar * pChar = static_cast <CChar*>( World.m_CharsIdle.GetHead()); pChar != NULL; pChar = pCharNext )
	{
		pCharNext = pChar->GetNext();
		if ( pChar->m_sAccount.IsEmpty())
			continue;
		if ( s.FindSec( pChar->m_sAccount ))
			continue;
		DEBUG_ERR(( "ERROR:Char '%s', has invalid account '%s'\n", pChar->GetName(), (const char*) pChar->m_sAccount ));
		delete pChar;
	}

	int iCount = 0;
	for ( int i=1; i<MAX_OBJECTS; i++ )
	{
		if ( UIDs[i] == NULL ) continue;
		iCount ++;
		if (( UIDs[i]->GetUID() & UID_MASK ) != i )
		{
			// Miss linked in the UID table !!! BAD
			// Hopefully it was just not linked at all. else How the hell should i clean this up ???
			DEBUG_ERR(( "ERROR:Object %d, '%s', Mislinked\n", i, UIDs[i]->GetName()));
			delete UIDs[i];
			UIDs[i] = NULL;	// Was not linked correctly.
		}
		// Are we displayed ?
		if ( ! UIDs[i]->IsValid())
		{
			if ( UIDs[i]->IsItem() )	// is m_pdef just set bad ?
			{
		
			}
			DEBUG_ERR(( "ERROR:Object %d, '%s', Invalid\n", i, UIDs[i]->GetName()));
			delete UIDs[i];
		}
	}
	if ( iCount != CObjBase::sm_iCount )	// All objects must be accounted for.
	{
		DEBUG_ERR(( "ERROR:Object memory leak %d!=%d\n", iCount, CObjBase::sm_iCount ));
	}
	else
	{
		DEBUG_MSG(( "%d Objects accounted for\n", iCount ));
	}

	Log.Flush();
}

void CWorld :: Speak( CObjBase * pSrc, const char * pText, WORD color, TALKMODE_TYPE mode, FONT_TYPE font )
{
	int range = 0;	// Broadcast i guess ?
	if ( pSrc != NULL )
	{
		switch ( mode )
		{
		case TALKMODE_BROADCAST:
			range = 0;
			break;
		case TALKMODE_WHISPER:
			range = 3;
			break;
		case TALKMODE_YELL:
			range = 0; // pSrc->GetVisualRange() * 2;
			break;
		default:
			range = pSrc->GetVisualRange();
			break;
		}
	}

	for ( CClient * pClient = Serv.GetClientHead(); pClient!=NULL; pClient = pClient->GetNext())
	{
		if ( pClient->m_pChar == NULL ) continue;
		if ( range )	// in range based on mode ?
		{
			if ( ! pClient->IsPriv( PRIV_BROADCAST ) // hear all.
				&& pClient->m_pChar->GetDist( pSrc ) > range ) 
				continue;
		}
		pClient->addBark( pText, pSrc, color, mode, font );
	}
}

void CWorld :: Broadcast( const char *pMsg ) // System broadcast in bold text
{
	Speak( NULL, pMsg, 0x03B2, TALKMODE_BROADCAST, FONT_BOLD );
	Serv.SocketsFlush();
}

bool CWorld :: GetTerrainData( int id, CUOTileTerrainBlock * pData ) const
{
	if ( id < 0 || id >= 0x800 ) return( false );

	long offset = ((( id / 32 ) + 1 ) * 4 ) + ( id * sizeof( *pData ));
	if ( m_TileFile.Seek( offset ))
		return( false );
	if ( ! m_TileFile.Read( pData, sizeof(*pData)))
		return( false );

	if ( ! pData->m_type &&	// 0xc0=water, 0x40=dirt or rock, 0x60=lava, 0x50=cave, 0=floor
		! pData->m_unk1	&&
		! pData->m_unk2	&&
		! pData->m_index &&	// just counts up.  0 = unused.
		! pData->m_name[0] )
		return( false );

	return( true );
}

void CWorld :: GetMapMeter( CPoint & p, CUOMapMeter & meter ) const // Height of MAP0.MUL at given coordinates
{
	int x1=p.m_x/UO_BLOCK_SIZE; // Block
	int y1=p.m_y/UO_BLOCK_SIZE;
	int x2=p.m_x%UO_BLOCK_SIZE; // Offset
	int y2=p.m_y%UO_BLOCK_SIZE;

	CUOMapBlock block;
	long pos = (x1*UO_BLOCKS_Y*sizeof(block)) +
		(y1*sizeof(block)) +
		(y2*sizeof(meter) * UO_BLOCK_SIZE ) +
		(x2*sizeof(meter)) + 4;

	m_MapFile.Seek( pos );
	m_MapFile.Read( &meter, sizeof( meter ));
}

bool CWorld :: GetItemData( ITEMID_TYPE id, CUOTileItemBlock * pData ) const
{
	// Invalid object id ?
	if ( id < 0 || id >= ITEMID_QTY ) return( false );
	if ( id >= ITEMID_BOAT_N ) 
	{
		// composite type objects.
		pData->m_flag2 = 0;
		pData->m_weight = 255;
		pData->m_layer = LAYER_NONE;
		pData->m_dwAnim = 0;
		pData->m_height = 0;
		strcpy( pData->m_name, "multi" );
		return( true );
	}

	long offset = 0x68800 + ((( id / 32 ) + 1 ) * 4 ) + ( id * sizeof( *pData ));
	if ( m_TileFile.Seek( offset ))
		return( false );
	if ( ! m_TileFile.Read( pData, sizeof(*pData)))
		return( false );

	// Unused tile I guess. Don't create it.
	if ( ! pData->m_type &&
		! pData->m_flag2 &&
		! pData->m_unk3 &&
		! pData->m_unk4 &&
		! pData->m_weight &&
		! pData->m_layer &&
		! pData->m_dwUnk7 &&
		! pData->m_dwAnim &&
		! pData->m_wUnk15 &&
		! pData->m_height &&
		! pData->m_name[0]
		)
		return( false );

	return( true );
}

signed char CWorld :: GetItemHeight( ITEMID_TYPE id, bool & fBlock ) const
{
	CUOTileItemBlock tile;
	if ( ! GetItemData( id, &tile ))
	{
		fBlock = true;
		return( -127 );
	}
	if ( tile.m_flag2 & 4 ) tile.m_height /= 2; // For Stairs+Ladders
	fBlock = ( tile.m_type & 0x40 );
	return( tile.m_height );
}

signed char CWorld :: GetHeight( CPoint & p, bool & fBlock ) const // Height of player who walked to X/Y/OLDZ
{
	// return z = -127 if invalid to go here ?
	 // Height of dynamic items at/above given coordinates
	signed char z = -127;
	signed char zhead = p.m_z + PLAYER_HEIGHT;

	// ??? bocking is based on ghost, swim and fly ?

	CWorldSearch Area( p );
	while ( 1 )
	{
		CItem * pItem = Area.GetItem();
		if ( pItem == NULL ) break;

		bool fBlockThis;
		signed char ztop = pItem->m_p.m_z + GetItemHeight( pItem->GetID(), fBlockThis );
		if ( ztop < z ) continue;
		if ( ! fBlockThis )
		{
			if ( zhead < ztop ) continue; // can walk under it.
			fBlock = false;
		}
		else
		{
			if ( zhead < pItem->m_p.m_z ) continue;
			if ( ztop <= z ) continue;
			fBlock = true;
		}
		z=ztop;
	}

	// Height of statics at/above given coordinates
	// do gravity here for the z.

	int x1=p.m_x/UO_BLOCK_SIZE; // Block
	int y1=p.m_y/UO_BLOCK_SIZE;
	int x2=p.m_x%UO_BLOCK_SIZE; // Offset
	int y2=p.m_y%UO_BLOCK_SIZE;

	CUOIndexBlock idx;
	long pos=(x1*UO_BLOCKS_Y*sizeof(idx))+(y1*sizeof(idx));
	m_SIdxFile.Seek( pos );
	m_SIdxFile.Read( &idx, sizeof(idx));

	if ( idx.m_dwOffset != 0xFFFFFFFF )  // no static items here.
	{
		// Go to the start of the statics block.
		m_StatFile.Seek( idx.m_dwOffset );

		CUOStaticsBlock stat;
	
		// fBlock = false;
		int i = idx.m_dwLength / sizeof(stat);
		while ( i-- )
		{
			m_StatFile.Read( &stat, sizeof(stat));
			if ( stat.m_x==x2 && stat.m_y==y2 )
			{
				// This static is at the coordinates in question.
				// enough room for me to stand here ?
				bool fBlockThis;
				signed char ztop = stat.m_z + GetItemHeight( (ITEMID_TYPE) stat.m_wID, fBlockThis );
				if ( ztop < z ) continue;
				if ( ! fBlockThis )
				{
					if ( zhead < ztop ) continue; // can walk under it.
					fBlock = false;
				}
				else
				{
					if ( zhead < stat.m_z ) continue;
					if ( ztop <= z ) continue;
					fBlock = true;
				}
				z=ztop;
			}
		}
	}
	else
	{
		fBlock = true;	// assume no static is a blocking thing for now.
	}

	CUOMapMeter meter;
	GetMapMeter( p, meter );
	if ( meter.m_z > z && meter.m_z < zhead )
	{
		z = meter.m_z;
		fBlock = false;
#ifdef COMMENT
		switch ( meter.m_wIndex )	// water tiles = we can swim
		{
		default:
		}
#endif
	}

	return( z );
}

bool CWorld :: CheckValidMove( CPoint & p ) const
{
	// Is it ok to move here ?
	// ignore dynamics for now.
	// Fill in the proper p.m_z value for this location as well.

	bool fBlock = false;
	signed char z = GetHeight( p, fBlock );

	if ( fBlock ) 
		return( false );
	if ( z > p.m_z + PLAYER_HEIGHT + 1 )	// Too high to climb.
		return( false );
	p.m_z = z;
	return( p.IsValid() );
}

void CWorld :: SetLight( int light )
{
	// light level = 0-18 or 19=dark

	// DEBUG_MSG(( "CWorld.SetLight(%d)\n", light ));

	m_globallight = light;
	for ( CClient * pClient = Serv.GetClientHead(); pClient!=NULL; pClient = pClient->GetNext())
	{
		if ( pClient->m_pChar == NULL ) continue;
		if ( pClient->m_pChar->m_StatFlag & ( STATF_DEAD | STATF_NightSight ))
			continue;
		pClient->addLight();
	}
}

void CWorld :: SetTime()
{
	// Set the game time from the real world clock.
	// Do this once per tick.

	m_Clock_PrevTime = m_Clock_Time;
	time_t Clock_Sys = clock();
	time_t Clock_New = m_Clock_Start + (( Clock_Sys - m_Clock_StartSys ) / CLOCKS_PER_SEC );

	if ( Clock_New < m_Clock_Time )	// should not happen (overflow)
	{
		DEBUG_ERR(( "CWorld.Clock overflow\n" ));
		m_Clock_StartSys = Clock_Sys;
		Clock_New = m_Clock_Start = m_Clock_Time;
	}
	m_Clock_Time = Clock_New;

	if ( ! ( m_Clock_Time & 0x1F ) && m_Clock_PrevTime != m_Clock_Time )	// check every 256 sec = 1 GRAY hour
	{
 		// 256 real secs = 1 GRAYhour. 19 light levels. check every 10 minutes or so.
		// moon out tonight ? = lighter at night.
		bool fNight = ( m_Clock_Time & 0x100 );	// Is it night or day ?
		BYTE bTargLight = (fNight) ? 16 : 0;	// Target light level.

		// Gradual transition to global light level.
		if ( m_globallight != bTargLight )
		{
			if ( m_globallight > bTargLight )
				m_globallight --;
			else
				m_globallight ++;
			SetLight( m_globallight );
		}
	}
}

WORD CWorld :: GetDayTimeMinutes() const
{
	// Get the time of the UO day in UO minutes
	// ???
	return( m_Clock_Time );
}

const char * CWorld :: GetInformation() const
{
	time_t total = m_Clock_Time;
	int hour = total/3600;
	total -= hour *3600;
	int min = total/60;
	total -= min * 60;
	int sec = total;
	char * pTemp = GetTempStr();
	sprintf( pTemp, GRAY_TITLE "Time up [%i:%i:%i] Clients [%i] Items [%i] Characters [%i]\n",
		hour,min,sec, Serv.m_Clients.GetCount(), CItem::sm_iCount, CChar::sm_iCount );
	return( pTemp );
}

void CWorld :: OnTick()
{
	if ( m_Clock_PrevTime == m_Clock_Time ) return;

	for ( int i=0; i<QUAD_QTY; i++ )
	{
		m_Quads[i].OnTick();
	}

	// Auto save world
	if ( m_Clock_Save <= m_Clock_Time )
	{
		m_Clock_Save = m_Clock_Time + (15*60);
		Log.Flush();
		if ( Serv.m_fSecure )
		{
			Save();
		}

		// Respawn dead NPC's 
		CChar * pChar = static_cast <CChar *>( World.m_CharsIdle.GetHead());
		for ( ; pChar != NULL; pChar = pChar->GetNext())
		{
			if ( pChar->m_NPC_Brain == NPCBRAIN_NONE ) continue;
			// Res them back to there "home"
			pChar->MoveTo( pChar->m_pHome->m_p );
			pChar->Spell_Resurrection();
		}
	}
}

struct CImportSer : public CObListRec
{
	// Translate the import UID's into my UID's
	DWORD m_dwSer;
	CObjBase * m_pObj;	// world object corresponding.
	DWORD m_dwContSer;
	LAYER_TYPE m_layer;
public:
	CImportSer( DWORD dwSer )
	{
		m_dwSer = dwSer;
		m_pObj = NULL;
		m_dwContSer = UID_UNUSED;
	}
};

bool CWorld :: Import( const char * pszFilename )
{
	CScript s;
	if ( ! s.Open( pszFilename ))
		return( false );

	//time_t OldClock_Start = m_Clock_Start;
	//m_Clock_Start = m_Clock_Time;	// trick into thinking it's loading.

	int mode = 0;
	CItem * pItem = NULL;
	CChar * pChar = NULL;
	CImportSer * pSer = NULL;
	CString sName;
	CObList ListSer;
	while ( 1 )
	{
		if ( s.ReadLine() == EOF ) 
			break;
		else if ( ! strnicmp( s.m_Line, "SECTION WORLDITEM", 17 ))
		{
			mode = 1;
			continue;
		}
		else if ( ! strnicmp( s.m_Line, "SECTION CHARACTER", 17 ))
		{
			// pChar = CharCreate( CREID_MAN );
			mode = 2;
			continue;
		}
		else if ( s.m_Line[0] == '{' )
			continue;
		else if ( s.m_Line[0] == '}' )
		{
closelast:
			if ( pSer != NULL )
			{
				if ( pSer->m_pObj != NULL )
				{
					if ( pSer->m_pObj == pChar ) pChar = NULL;
					if ( pSer->m_pObj == pItem ) pItem = NULL;
				}
				pSer = NULL;
			}
			if ( pChar != NULL ) 
			{
				delete pChar;
				pChar = NULL;
			}
			if ( pItem != NULL )
			{
				delete pItem;
				pItem = NULL;
			}
			mode = 0;
			continue;
		}
		else if ( mode == 0 )
			continue;
		else if ( s.m_Line[0] == '\\' )
			continue;

		// Parse the line.
		char * pArg = strchr( s.m_Line, ' ' );
		if ( pArg != NULL ) 
		{
			*pArg++ = '\0';
			while ( *pArg == ' ' ) pArg++;
		}
		else
		{
			pArg = "";
		}
		if ( ! strcmpi( s.m_Line, "SERIAL" ))
		{
			if ( pSer != NULL ) 
				return( false );

			DWORD dwSerial = atoi( pArg );
			if ( dwSerial == UID_UNUSED )
			{
				DEBUG_ERR(( "ERROR:Import:Bad serial number\n" ));
				break;
			}
			pSer = new CImportSer( dwSerial );
			ListSer.InsertAfter( pSer );
			continue;
		}
		if ( pSer == NULL )
		{
			DEBUG_ERR(( "ERROR:Import:No serial number\n" ));
			break;
		}
		if ( mode == 1 )	// CItem.
		{
			if ( ! strcmpi( s.m_Line, "NAME" ))
			{
				sName = ( pArg[0] == '#' ) ? "" : pArg;
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "ID" ))
			{
				if ( pItem != NULL ) 
					return( false );
				pItem = ItemCreateScript( (ITEMID_TYPE) atoi( pArg ));
				pItem->SetName( sName );
				pSer->m_pObj = pItem;
				continue;
			}

			if ( pItem == NULL )
			{
				DEBUG_ERR(( "ERROR:Import:Bad Item Key '%s'\n", s.m_Line ));
				break;
			}
			if ( ! strcmpi( s.m_Line, "CONT" ))
			{
				pSer->m_dwContSer = atoi(pArg);
			}
			else if ( ! strcmpi( s.m_Line, "X" ))
			{
				pItem->m_p.m_x = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "Y" ))
			{
				pItem->m_p.m_y = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "Z" ))
			{
				pItem->m_p.m_z = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "COLOR" ))
			{
				pItem->m_color = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "LAYER" ))
			{
				pSer->m_layer = (LAYER_TYPE) atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "AMOUNT" ))
			{
				pItem->m_amount = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MOREX" ))
			{
				pItem->m_magic_p.m_x = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MOREY" ))
			{
				pItem->m_magic_p.m_y = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MOREZ" ))
			{
				pItem->m_magic_p.m_z = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MORE" ))
			{
				pItem->m_more1 = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MORE2" ))
			{
				pItem->m_more2 = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "DYEABLE" ))
			{
				if ( atoi(pArg))
					pItem->m_pDef->m_Can |= CAN_DYE;
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "MOVABLE" ))
			{
				int i = atoi(pArg);
				if ( i & 1 ) pItem->m_Attr |= ATTR_MOVE_ALWAYS;
				if ( i & 2 ) pItem->m_Attr |= ATTR_MOVE_NEVER;
			}
			else if ( ! strcmpi( s.m_Line, "ATT" ))
			{
				pItem->m_pDef->m_attack = atoi(pArg);
			}
			else if ( ! strcmpi( s.m_Line, "TYPE" ))
			{
				// ??? translate the type field.
				int i = atoi(pArg);

			}
#ifdef COMMENT
  fprintf(wscfile, "DEF %i\n", items[i].def);
  fprintf(wscfile, "VISIBLE %i\n", items[i].visible);
  fprintf(wscfile, "SPAWN %i\n", (items[i].spawn1*16777216)+(items[i].spawn2*65536)+(items[i].spawn3*256)+items[i].spawn4);
  fprintf(wscfile, "CORPSE %i\n", items[i].corpse);
  fprintf(wscfile, "OWNER %i\n", (items[i].owner1*16777216)+(items[i].owner2*65536)+(items[i].owner3*256)+items[i].owner4);
#endif
		}
		if ( mode == 2 )
		{
			if ( ! strcmpi( s.m_Line, "NAME" ))
			{
				if ( pChar != NULL ) 
					return( false );
				pChar = CharCreate( CREID_MAN );
				pChar->SetName( sName );
				pSer->m_pObj = pChar;
				continue;
			}
			if ( pChar == NULL )
			{
				DEBUG_ERR(( "ERROR:Import:Bad Item Key '%s'\n", s.m_Line ));
				break;
			}
			if ( ! strcmpi( s.m_Line, "X" ))
			{
				pChar->m_p.m_x = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "Y" ))
			{
				pChar->m_p.m_y = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "Z" ))
			{
				pChar->m_p.m_z = atoi(pArg);
				pChar->MoveTo( pChar->m_p );
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "BODY" ))
			{
				pChar->SetID( (CREID_TYPE) atoi(pArg));
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "SKIN" ))
			{
				pChar->m_color = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "DIR" ))
			{
				pChar->m_dir = (DIR_TYPE) atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "XBODY" ))
			{
				pChar->m_prev_id = (CREID_TYPE) atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "XSKIN" ))
			{
				pChar->m_prev_color = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "FONT" ))
			{
				pChar->m_fonttype = (FONT_TYPE) atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "KARMA" ))
			{
				pChar->m_Stat[STAT_Karma] = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "FAME" ))
			{
				pChar->m_Stat[STAT_Fame] = atoi(pArg);
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "TITLE" ))
			{
				pChar->m_sTitle = pArg;
				continue;
			}
			else if ( ! strcmpi( s.m_Line, "STRENGTH" ))
			{
				pChar->m_Stat[STAT_STR] = atoi(pArg);;
			}
			else if ( ! strcmpi( s.m_Line, "DEXTERITY" ))
			{
				pChar->m_Stat[STAT_DEX] = atoi(pArg);;
			}
			else if ( ! strcmpi( s.m_Line, "INTELLIGENCE" ))
			{
				pChar->m_Stat[STAT_INT] = atoi(pArg);;
			}
			else if ( ! strcmpi( s.m_Line, "HITPOINTS" ))
			{
				pChar->m_health = atoi(pArg);;
			}
			else if ( ! strcmpi( s.m_Line, "STAMINA" ))
			{
				pChar->m_stam = atoi(pArg);;
			}
			else if ( ! strcmpi( s.m_Line, "MANA" ))
			{
				pChar->m_mana = atoi(pArg);;
			}
			else if ( ! strnicmp( s.m_Line, "SKILL", 5 ))
			{
				int iskill = atoi( &(s.m_Line[5]));
				if ( iskill < SKILL_QTY )
				{
					pChar->m_Skill[iskill] = atoi(pArg);
				}
			}
			else if ( ! strcmpi( s.m_Line, "NPCAITYPE" ))
			{
				if ( atoi(pArg))
					pChar->m_NPC_Brain = NPCBRAIN_ANIMAL;				
			}
#ifdef COMMENT
  fprintf(wscfile, "NPC %i\n", chars[i].npc);
  fprintf(wscfile, "SPEECH %i\n", chars[i].speech);
  fprintf(wscfile, "WAR %i\n", chars[i].war);
  fprintf(wscfile, "OWN %i\n", (chars[i].own1*16777216)+(chars[i].own2*65536)+(chars[i].own3*256)+chars[i].own4);
  fprintf(wscfile, "ATT %i\n", chars[i].att);
  fprintf(wscfile, "DEF %i\n", chars[i].def);
  fprintf(wscfile, "ACCOUNT %i\n", chars[i].account);
  fprintf(wscfile, "ALLMOVE %i\n", chars[i].priv2);
  fprintf(wscfile, "STRENGTH2 %i\n", chars[i].st2);
  fprintf(wscfile, "DEXTERITY2 %i\n", chars[i].dx2);
  fprintf(wscfile, "INTELLIGENCE2 %i\n", chars[i].in2);
  fprintf(wscfile, "KILLS %i\n", chars[i].kills);
  fprintf(wscfile, "DEATHS %i\n", chars[i].deaths);
  fprintf(wscfile, "DEAD %i\n", chars[i].dead);
  fprintf(wscfile, "PACKITEM %i\n", chars[i].packitem);
  fprintf(wscfile, "RESERVED1 %i\n", chars[i].cell);
  fprintf(wscfile, "NPCWANDER %i\n", chars[i].npcWander); 
  fprintf(wscfile, "FOLLOWTARGET %i\n", (chars[i].ftarg1*16777216)+(chars[i].ftarg2*65536)+(chars[i].ftarg3*256)+chars[i].ftarg4);
  fprintf(wscfile, "FX1 %i\n", chars[i].fx1);
  fprintf(wscfile, "FY1 %i\n", chars[i].fy1);
  fprintf(wscfile, "FZ1 %i\n", chars[i].fz1);
  fprintf(wscfile, "FX2 %i\n", chars[i].fx2);
  fprintf(wscfile, "FY2 %i\n", chars[i].fy2);
  fprintf(wscfile, "SPAWN %i\n", (chars[i].spawn1*16777216)+(chars[i].spawn2*65536)+(chars[i].spawn3*256)+chars[i].spawn4);
  fprintf(wscfile, "ROBE %i\n", (chars[i].robe1*16777216)+(chars[i].robe2*65536)+(chars[i].robe3*256)+chars[i].robe4);
#endif
			continue;
		}
	}

	// now fix the contained items.

	pSer = static_cast <CImportSer*> ( ListSer.GetHead());
	for ( ; pSer != NULL; pSer = static_cast <CImportSer*> ( pSer->GetNext()))
	{
		if ( pSer->m_pObj == NULL ) continue;

		// Make sure this item is not a dupe ?

		if ( pSer->m_dwContSer == UID_UNUSED )
		{
			if ( pSer->m_pObj->IsItem()) 
			{
				CWorldSearch AreaItems( pSer->m_pObj->m_p );
				while ( 1 )
				{
					CItem * pItem = AreaItems.GetItem();
					if ( pItem == NULL ) break;
					if ( ! pItem->IsSameType( pSer->m_pObj )) continue;
					pItem->SetName( pSer->m_pObj->m_sName );
					DEBUG_ERR(( "ERROR:Import:Dupe item\n" ));
					delete pSer->m_pObj;
					break;
				}
			}
			else
			{

			}
			continue;
		}

		// Find it's container.
		CImportSer* pSerCont = static_cast <CImportSer*> ( ListSer.GetHead());
		for ( ; pSerCont != NULL; pSerCont = static_cast <CImportSer*> ( pSerCont->GetNext()))
		{
			if ( pSerCont->m_pObj == NULL ) continue;
			if ( pSerCont->m_dwSer == pSer->m_dwContSer )
			{
				if ( ! ( dynamic_cast <CItem*>(pSer->m_pObj))->LoadSetContainer( pSerCont->m_pObj->GetUID(), pSer->m_layer ))
				{
					delete pSer->m_pObj;
				}
				pSer->m_dwContSer = UID_UNUSED;	// found it.
				break;
			}
		}
		if ( pSer->m_dwContSer != UID_UNUSED )
		{
			DEBUG_ERR(( "ERROR:Import:Invalid item container\n" ));
			delete pSer->m_pObj;
		}
	}

	GarbageCollection();
	//m_Clock_Start = OldClock_Start;	// restore.

	return( true );
}

bool CWorld :: CommandLine( int argc, char * argv[] )
{
	// RETURN:
	//  true = keep running after this.
	//

	if ( argv[1][0] == '1' )
	{
		// dump the items database.
		CFile File;
		if ( ! File.Open( "items.txt", true ))
			return( false );
		for ( int i = 0; i < ITEMID_BOAT_N; i++ )
		{
			CUOTileItemBlock item;
			if ( ! GetItemData( (ITEMID_TYPE) i, &item ))
				continue;
			File.Printf( "%04x: %02x,F%02x,%02x,%02x,W%02x,L%02x,?%08x,A%08x,?%04x,H%02x,'%s'\n",
				i,
				item.m_type,
				item.m_flag2,	// flag = 0x04 = climbable. m_height /= 2(For Stairs+Ladders)
				item.m_unk3,
				item.m_unk4,
				item.m_weight,
				item.m_layer,
				item.m_dwUnk7,
				item.m_dwAnim,
				item.m_wUnk15,
				item.m_height,
				item.m_name );
		}
		return( false );
	}

	if ( argv[1][0] == '2' )
	{
		// dump the ground tiles database.
		CFile File;
		if ( ! File.Open( "terrain.txt", true ))
			return( false );

		for ( int i=0; i<0x800; i++ )
		{
			CUOTileTerrainBlock block;
			if ( ! GetTerrainData( (ITEMID_TYPE) i, &block ))
				continue;
			File.Printf( "%04x: %02x,%02x,%04x,%04x,'%s'\n",
				i,
				block.m_type,	// 0xc0=water, 0x40=dirt or rock, 0x60=lava, 0x50=cave, 0=floor
				block.m_unk1,
				block.m_unk2,
				block.m_index,	// just counts up.  0 = unused.
				block.m_name );
		}
		return( false );
	}

	Log.Error( "Don't recognize command line data '%s'\n", argv[1] );
	return( true );
}
